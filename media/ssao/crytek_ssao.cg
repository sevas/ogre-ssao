struct AppData
{
    float4 p   : POSITION;
    float3 n   : NORMAL;
    float2 uv  : TEXCOORD0;
};

struct VertexOut
{
    float4 p             : POSITION;
    float2 pixelPos      : TEXCOORD0;
    float3 eyeViewVector : TEXCOORD1;
};

struct FragmentInput
{
    float2 pixelPos      : TEXCOORD0;
    float3 eyeViewVector : TEXCOORD1;
};

//------------------------------------------------------------------------------
VertexOut crytek_ssao_vs(AppData IN, uniform float4x4 wvp, uniform float3 farCorner)
{
    VertexOut OUT;
    OUT.p = mul(wvp, IN.p);
    // clean up inaccuracies for the UV coords
    float2 uv = sign(IN.p);
    // convert to image space
    uv = (float2(uv.x, -uv.y) + 1.0) * 0.5;
    OUT.pixelPos = uv;
    // calculate the correct ray (modify XY parameters based on screen-space quad XY)
    OUT.eyeViewVector = farCorner * float3(sign(IN.p.xy), 1);
    
	return OUT;
}
////------------------------------------------------------------------------------
//float3 computeZ(float2 xy)
//{
    //return float3(xy, sqrt(1.0 - dot(xy, xy)));
//}
////------------------------------------------------------------------------------
//// for ps_3_0, we want to use tex2Dlod because it's faster
//ps_3_0 float4 TEX2DLOD(sampler2D map, float2 uv)
//{
    //return tex2Dlod(map, float4(uv.xy, 0, 0));
//}
////------------------------------------------------------------------------------
//float4 TEX2DLOD(sampler2D map, float2 uv)
//{
    //return tex2D(map, uv);
//}
//------------------------------------------------------------------------------

#define PI 3.14159265
#define NUM_SAMPLES 32
#define RADIUS 0.01

void crytek_ssao_ps(
    FragmentInput IN
    //uniform float4x4 ptMat,
    ,uniform float far
    ,uniform sampler2D geomMap : TEXUNIT0
	,uniform sampler2D randMap : TEXUNIT1
	,out float4 oColor : COLOR0)
{

	float depth = tex2D(geomMap, IN.pixelPos).x /far ;
	

	int count = 0;
	float occlusion = 0.0f;
    for( int i=0; i<NUM_SAMPLES; i++ )
    {
		float x, y;
		float angle = float(i) * 2*PI/NUM_SAMPLES; 
		sincos(angle, x, y);
		float2 spherePointCoords = IN.pixelPos + RADIUS * float2(x, y);

		float spherePointDepth = tex2D(geomMap, spherePointCoords).x /far  ;

		float diff = max(depth - spherePointDepth, 0.0f);
		if(diff > 0.0f)
		{
			count += 1;
			occlusion += 300 * diff;
		}
	}

	if (count < NUM_SAMPLES/2)
		occlusion = 0.0f;

	occlusion = 1.0f - occlusion;
	oColor = float4(occlusion, occlusion, occlusion, 1);
}