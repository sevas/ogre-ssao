struct AppData
{
    float4 p   : POSITION;
    float3 n   : NORMAL;
    float2 uv  : TEXCOORD0;
};

struct VertexOut
{
    float4 p             : POSITION;
    float2 pixelPos      : TEXCOORD0;
    float3 eyeViewVector : TEXCOORD1;
};

struct FragmentInput
{
    float2 pixelPos      : TEXCOORD0;
    float3 eyeViewVector : TEXCOORD1;
};

//------------------------------------------------------------------------------
VertexOut crytek_ssao_vs(AppData IN, uniform float4x4 wvp, uniform float3 farCorner)
{
    VertexOut OUT;
    OUT.p = mul(wvp, IN.p);
    // clean up inaccuracies for the UV coords
    float2 uv = sign(IN.p);
    // convert to image space
    uv = (float2(uv.x, -uv.y) + 1.0) * 0.5;
    OUT.pixelPos = uv;
    // calculate the correct ray (modify XY parameters based on screen-space quad XY)
    OUT.eyeViewVector = farCorner * float3(sign(IN.p.xy), 1);
    
	return OUT;
}
////------------------------------------------------------------------------------
//float3 computeZ(float2 xy)
//{
    //return float3(xy, sqrt(1.0 - dot(xy, xy)));
//}
////------------------------------------------------------------------------------
//// for ps_3_0, we want to use tex2Dlod because it's faster
//ps_3_0 float4 TEX2DLOD(sampler2D map, float2 uv)
//{
    //return tex2Dlod(map, float4(uv.xy, 0, 0));
//}
////------------------------------------------------------------------------------
//float4 TEX2DLOD(sampler2D map, float2 uv)
//{
    //return tex2D(map, uv);
//}
//------------------------------------------------------------------------------



#define PI 3.14159265
#define NUM_SAMPLES 16
#define INV_SAMPLES 1.0f / 16.0f
#define R_FAR 0.6




float compute_h(float3 PC, float r)
{
   return 1.0f - cos(asin(r/length(PC)));
}

//------------------------------------------------------------------------------


float compute_sphere_cap_area(float3 PC, float r)
{
	float h = compute_h(PC, r);
	return 2*PI*h;
}



//------------------------------------------------------------------------------

float compute_approximate_AO(float3 C, float r, float3 P, float3 n)
{
	float3 PC = P-C;
	return compute_sphere_cap_area(PC, r) * max(dot(n, normalize(PC)), 0.0f);
}

//------------------------------------------------------------------------------

void crytek_ssao_ps(
    FragmentInput IN
    ,uniform sampler2D geomMap : TEXUNIT0
	,uniform sampler2D randMap : TEXUNIT1
	,uniform float radius
	,uniform float totStrength
	,uniform float strength
	,uniform float offset
	,uniform float falloff	
	,out float4 oColor : COLOR0)
{
	float4 sample = tex2D(geomMap, IN.pixelPos);
	float depth = sample.a;
	float3 normal = sample.rgb;

	float3 P = float3(IN.pixelPos, depth);
	float occlusion = 0.0f;
	
	for(int i=0 ; i<2; i++)
	{
		for(float theta=0.0f; theta < 2*PI ; theta += PI/4)
		{
			float2 neighbour_coords = IN.pixelPos + (radius * i * float2(cos(theta), sin(theta)));
			float neighbour_depth = tex2D(geomMap, neighbour_coords).a;
			float3 Qi = float3(neighbour_coords, neighbour_depth);
			float ri = radius;

			if (length(P - Qi)  < R_FAR)
			{
				occlusion += compute_approximate_AO(Qi, ri, P, normal);
			}			
		}
	}
	//occlusion = 1.0f - (occlusion*50);
	occlusion *= 10;
	oColor=float4(occlusion, occlusion, occlusion, 1.0f);

}