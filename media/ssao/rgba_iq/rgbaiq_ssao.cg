struct AppData
{
    float4 p   : POSITION;
    float3 n   : NORMAL;
    float2 uv  : TEXCOORD0;
};

struct VertexOut
{
    float4 p             : POSITION;
    float2 pixelPos      : TEXCOORD0;
};

struct FragmentInput
{
    float2 pixelPos      : TEXCOORD0;
};

//------------------------------------------------------------------------------
VertexOut rgbaiq_ssao_vs(AppData IN, uniform float4x4 wvp, uniform float3 farCorner)
{
    VertexOut OUT;
    OUT.p = mul(wvp, IN.p);
    // clean up inaccuracies for the UV coords
    float2 uv = sign(IN.p.xy);
    OUT.p = float4(uv, 0, 1);
    

    // convert to image space
    uv = (float2(uv.x, -uv.y) + 1.0) * 0.5;
    OUT.pixelPos = uv;
    
	return OUT;
}


//------------------------------------------------------------------------------


#define PI 3.141592653
#define PIXELSIZE 0.0003

void rgbaiq_ssao_ps(
     FragmentInput IN
    ,uniform sampler2D geomMap : TEXUNIT0
	,uniform sampler2D randMap : TEXUNIT1
	,uniform sampler1D colorMap : TEXUNIT2
    ,out float4 oColor)
{

    float4 sample = tex2D(geomMap, IN.pixelPos);
    float z = sample.r ;


    float3 P = float3(IN.pixelPos, z);
    
    float max_delta_depth = 0.0;
    
    int count = 0;
    
    
    
    for (int i=0 ; i<8; i++)
    {
        float x, y;
        sincos(i*PI / 8, x, y);
         
        float2 coords = z*PIXELSIZE * float2(x, y);
         
        float2 neighbour_coords = IN.pixelPos + coords;
         
        float sampled_depth = tex2D(geomMap,  neighbour_coords);
         
        float3 Q = float3(neighbour_coords, sampled_depth);
         
         
        float len = length(P-Q);
        //float len = abs(z-sampled_depth);
        
        if(sampled_depth < z && len<0.02)
        {
            count += 1;
        }
    }
    
    if(count > 4)
        oColor = float4(0, 0, 0, 1);
    else
        oColor = float4(1);
    
}
