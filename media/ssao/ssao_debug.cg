struct VIn
{
    float4 p   : POSITION;
    float3 n   : NORMAL;
    float2 uv  : TEXCOORD0;
};

struct VOut
{
    float4 p   : POSITION;
    float2 uv  : TEXCOORD0;
};

struct PIn
{
    float2 uv  : TEXCOORD0;
};



VOut ssao_debug_vs(VIn IN, uniform float4x4 wvp)
{
    VOut OUT;
    OUT.p = mul(wvp, IN.p);
    // clean up inaccuracies for the UV coords
    float2 uv = sign(IN.p);
    // convert to image space
    uv = (float2(uv.x, -uv.y) + 1.0) * 0.5;
    OUT.uv = uv;
    // calculate the correct ray (modify XY parameters based on screen-space quad XY)
    return OUT;
}






float4 ssao_debug_ps(
    PIn IN,
    uniform float4x4 ptMat,
    uniform sampler2D geomMap : TEXUNIT0
    ,uniform sampler2D  ssaoResult: TEXUNIT1
    ,uniform sampler2D diffuseOnly : TEXUNIT2
    ,uniform sampler2D finalScene : TEXUNIT3
    ): COLOR0
{

	float4 oColor = float4(0,0,0,0);
	float2 coords = IN.uv;

	if(coords.y < 0.3f)
	{
		if(coords.x < 0.33f)
		{
			float depth = tex2D(geomMap, float2(1.0f/0.33, 1.0/0.33) * (coords - float2(0, 0.3))).x;	
			oColor = float4(depth, depth, depth, 1.0f); 
		}
		else if(coords.x < 0.66f)
		{
			float3 normal = tex2D(geomMap, float2(1.0/0.3, 1.0/0.3) * (coords - float2(0.33, 0.3))).yzw;	
			oColor = float4(normal, 1.0f); 
		}
		else
		{
			oColor = tex2D(ssaoResult, float2(1.0/0.3, 1.0/0.3) * (coords - float2(0.66, 0.3)));		
		}		
	}
	else
	{
		if(coords.x < 0.5f)
		{	
			//diffuse only
			oColor =  float4(1.0f, 0.0f, 0.0f, 1.0f);	
			oColor = tex2D(diffuseOnly, float2(1.0/0.5, 1.0/0.7) * (coords - float2(0,0.3)));
		}	
		else
		{
			// final scene
			oColor =  float4(0.0f, 1.0f, 0.0f, 1.0f);	
			oColor = tex2D(finalScene, float2(1.0/0.5, 1.0/0.7) * (coords - float2(0.5,0.3)));
		}
	}

//    return tex2D(ssaoResult, IN.uv);
	return oColor;
}
